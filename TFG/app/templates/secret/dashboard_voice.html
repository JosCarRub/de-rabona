{% load static %}
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente IA 3D Interactivo</title>
    <link rel="stylesheet" href="{% static 'css/agent_styles.css' %}">
    <link rel="icon" href="{% static 'favicon.svg' %}" type="image/svg+xml">

</head>
<body>
    <!-- Navegaci√≥n Superior Izquierda -->
    <nav class="top-nav">
        <a href="{% url 'home' %}" class="nav-link">Volver a la aplicaci√≥n</a>
        <a href="{% url 'dashboard' %}" class="nav-link">Volver al chat</a>
    </nav>

    <!-- Contenedor del Modelo 3D -->
    <div id="container">
        <div id="loading">
            CARGANDO MODELO 3D...<br>
            [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] 100%
        </div>
    </div>

    <!-- Panel de Control -->
    <div id="textureControls">
        <div class="controls-header" onclick="toggleControls()">
            <strong>PANEL DE CONTROL</strong>
            <div class="toggle-button" id="toggleBtn">‚àí</div>
        </div>
        
        <div class="controls-content" id="controlsContent">
            <strong>TEXTURAS DISPONIBLES:</strong><br><br>
        
            <button class="texture-button active" data-texture="mist">
                NEBLINA ET√âREA
            </button>
            <button class="texture-button" data-texture="lasergrid">
                REJILLA L√ÅSER
            </button>
        
            <div class="section-divider">
                <strong>CONFIGURACI√ìN:</strong>
            </div>
        
            <div class="slider-container">
                <label>Intensidad:</label>
                <input type="range" class="slider" id="intensitySlider" min="0.1" max="2.5" step="0.1" value="1">
            </div>
        
            <div class="slider-container">
                <label>Velocidad:</label>
                <input type="range" class="slider" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
            </div>
        
            <div class="slider-container">
                <label>Densidad:</label>
                <input type="range" class="slider" id="densitySlider" min="0.3" max="3" step="0.1" value="1">
            </div>
        
            <div class="section-divider">
                <strong>COLOR DEL FONDO:</strong>
            </div>
        
            <div class="color-picker">
                <div class="color-option active" data-bg-color="black" style="background: #0a0a0a; border: 1px solid #333;"></div>
                <div class="color-option" data-bg-color="white" style="background: #ffffff;"></div>
                <div class="color-option" data-bg-color="dark-gray" style="background: #1a1a1a;"></div>
                <div class="color-option" data-bg-color="dark-blue" style="background: #0a0a1a;"></div>
                <div class="color-option" data-bg-color="light-gray" style="background: #c0c0c0;"></div>
            </div>
        
            <div class="section-divider">
                <strong>COLOR DEL MODELO:</strong>
            </div>
        
            <div class="color-picker">
                <div class="color-option active" data-model-color="black" style="background: #0a0a0a; border: 1px solid #333;"></div>
                <div class="color-option" data-model-color="dark-gray" style="background: #2a2a2a;"></div>
                <div class="color-option" data-model-color="gray" style="background: #555555;"></div>
                <div class="color-option" data-model-color="silver" style="background: #888888;"></div>
                <div class="color-option" data-model-color="white" style="background: #ffffff;"></div>
                <div class="color-option" data-model-color="dark-blue" style="background: #001133;"></div>
                <div class="color-option" data-model-color="dark-purple" style="background: #220033;"></div>
                <div class="color-option" data-model-color="dark-green" style="background: #003322;"></div>
            </div>
        
            <div class="section-divider">
                <strong>PALETA DE TEXTURAS:</strong>
            </div>
        
            <div class="color-picker">
                <div class="color-option active" data-color="cyan" style="background: #00ffff;"></div>
                <div class="color-option" data-color="mint" style="background: #7fffd4;"></div>
                <div class="color-option" data-color="purple" style="background: #8a2be2;"></div>
                <div class="color-option" data-color="pink" style="background: #ff1493;"></div>
                <div class="color-option" data-color="green" style="background: #00ff41;"></div>
                <div class="color-option" data-color="orange" style="background: #ff6600;"></div>
                <div class="color-option" data-color="blue" style="background: #0066ff;"></div>
                <div class="color-option" data-color="white" style="background: #ffffff;"></div>
            </div>
        </div>
    </div>

    <!-- √Årea de Texto -->
    <div class="input-area">
        <textarea id="voiceInput" placeholder="Escribe tu mensaje o usa el micr√≥fono..."></textarea>
        <div class="input-controls">
            <button id="voiceBtn" class="control-btn voice-btn">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="sendBtn" class="control-btn send-btn">
                <i class="fas fa-paper-plane"></i>
            </button>
            <button id="muteBtn" class="control-btn mute-btn">
                <i class="fas fa-volume-up"></i>
            </button>
            <input type="range" id="volumeRange" min="0" max="100" value="80" class="volume-slider">
        </div>
        <div class="status-indicator">
            <div id="statusDot" class="status-dot"></div>
            <span id="statusText">Listo para escuchar</span>
        </div>
    </div>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Three.js Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
            "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.128.0/examples/jsm/loaders/GLTFLoader.js"
        }
    }
    </script>

    <!-- Script del Modelo 3D -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

        // Variables globales del modelo 3D
        let scene, camera, renderer, controls;
        let glitchTexture, glitchCanvas, glitchContext;
        let model, glitchMaterial;
        let time = 0;
        let animationState = 'idle'; // idle, processing, speaking
        
        // Variables para transiciones fluidas
        let targetRotationX = 0;
        let targetRotationY = 0;
        let targetRotationZ = 0;
        let targetPositionZ = 0;
        let currentRotationX = 0;
        let currentRotationY = 0;
        let currentRotationZ = 0;
        let currentPositionZ = 0;
        const transitionSpeed = 0.05; // Velocidad de interpolaci√≥n (0.05 = suave)

        // Configuraci√≥n de textura
        const textureSize = 512;
        let currentTexture = 'mist';
        let intensity = 0.7;
        let speed = 1.4;
        let density = 1;
        let currentColor = 'green';
        let currentModelColor = 'white';
        let currentBgColor = 'black';

        // Paleta de colores
        const colorPalettes = {
            purple: { primary: '#8a2be2', secondary: '#da70d6', accent: '#dda0dd' },
            cyan: { primary: '#00ffff', secondary: '#7fffd4', accent: '#a0ffff' },
            mint: { primary: '#7fffd4', secondary: '#00ffff', accent: '#e0ffff' },
            pink: { primary: '#ff1493', secondary: '#ff69b4', accent: '#ffb6c1' },
            green: { primary: '#00ff41', secondary: '#32cd32', accent: '#98fb98' },
            orange: { primary: '#ff6600', secondary: '#ff8c00', accent: '#ffa500' },
            blue: { primary: '#0066ff', secondary: '#4169e1', accent: '#87ceeb' },
            white: { primary: '#ffffff', secondary: '#f0f0f0', accent: '#e0e0e0' }
        };

        const modelColors = {
            black: 0x0a0a0a,
            'dark-gray': 0x2a2a2a,
            gray: 0x555555,
            silver: 0x888888,
            white: 0xffffff,
            'dark-blue': 0x001133,
            'dark-purple': 0x220033,
            'dark-green': 0x003322
        };

        const bgColors = {
            black: 0x0a0a0a,
            white: 0xffffff,
            'dark-gray': 0x1a1a1a,
            'dark-blue': 0x0a0a1a,
            'light-gray': 0xc0c0c0
        };

        // Funci√≥n global para controlar animaciones desde chat-logic.js
        window.setAnimationState = function(state) {
            animationState = state;
            console.log('üé≠ Estado de animaci√≥n cambiado a:', state);
        };

        // Funci√≥n global para toggle de controles
        window.toggleControls = function() {
            const content = document.getElementById('controlsContent');
            const btn = document.getElementById('toggleBtn');
            
            content.classList.toggle('collapsed');
            
            if (content.classList.contains('collapsed')) {
                btn.textContent = '+';
            } else {
                btn.textContent = '‚àí';
            }
        };

        // Inicializaci√≥n
        init();
        animate();

        function init() {
            setupScene();
            createGlitchTexture();
            setupLighting();
            setupControls();
            loadModel();
            
            window.addEventListener('resize', onWindowResize);
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(bgColors[currentBgColor]);
            scene.fog = new THREE.Fog(bgColors[currentBgColor], 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 4);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.enablePan = false;
            controls.minDistance = 6;
            controls.maxDistance = 10;
            controls.maxPolarAngle = Math.PI * 0.8;
            controls.minPolarAngle = Math.PI * 0.2;
            controls.target.set(0, 0, 0);
        }

        function createGlitchTexture() {
            glitchCanvas = document.createElement('canvas');
            glitchCanvas.width = textureSize;
            glitchCanvas.height = textureSize;
            glitchContext = glitchCanvas.getContext('2d');

            glitchTexture = new THREE.CanvasTexture(glitchCanvas);
            glitchTexture.wrapS = THREE.RepeatWrapping;
            glitchTexture.wrapT = THREE.RepeatWrapping;
            glitchTexture.generateMipmaps = false;
            glitchTexture.minFilter = THREE.LinearFilter;
            glitchTexture.magFilter = THREE.LinearFilter;

            glitchMaterial = new THREE.MeshStandardMaterial({
                color: modelColors[currentModelColor],
                emissiveMap: glitchTexture,
                emissive: new THREE.Color(0xffffff),
                emissiveIntensity: 1.0,
                roughness: 0.1,
                metalness: 0.9,
                transparent: false,
                opacity: 1
            });

            updateTexture();
        }

        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x202020, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x404040, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            updateLighting();
        }

        function updateLighting() {
            const lightsToRemove = scene.children.filter(child => 
                child.type === 'PointLight' && child.userData.dynamic
            );
            lightsToRemove.forEach(light => scene.remove(light));

            const colors = colorPalettes[currentColor];
            
            const accentLight = new THREE.PointLight(colors.primary, 1.5, 12);
            accentLight.position.set(-3, 2, 3);
            accentLight.userData.dynamic = true;
            scene.add(accentLight);

            const fillLight = new THREE.PointLight(colors.secondary, 1.0, 10);
            fillLight.position.set(2, -1, -2);
            fillLight.userData.dynamic = true;
            scene.add(fillLight);

            const extraLight = new THREE.PointLight(colors.accent, 0.8, 8);
            extraLight.position.set(0, 3, 2);
            extraLight.userData.dynamic = true;
            scene.add(extraLight);
        }

        function setupControls() {
            // Botones de textura
            document.querySelectorAll('.texture-button').forEach(button => {
                button.addEventListener('click', () => {
                    document.querySelectorAll('.texture-button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    currentTexture = button.dataset.texture;
                    updateTexture();
                });
            });

            // Selector de colores para texturas
            document.querySelectorAll('.color-option[data-color]').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.color-option[data-color]').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentColor = option.dataset.color;
                    updateLighting();
                    updateTexture();
                });
            });

            // Selector de colores para el fondo
            document.querySelectorAll('.color-option[data-bg-color]').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.color-option[data-bg-color]').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentBgColor = option.dataset.bgColor;
                    updateBackgroundColor();
                });
            });

            // Selector de colores para el modelo
            document.querySelectorAll('.color-option[data-model-color]').forEach(option => {
                option.addEventListener('click', () => {
                    document.querySelectorAll('.color-option[data-model-color]').forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    currentModelColor = option.dataset.modelColor;
                    updateModelColor();
                });
            });

            // Sliders
            document.getElementById('intensitySlider').addEventListener('input', (e) => {
                intensity = parseFloat(e.target.value);
            });

            document.getElementById('speedSlider').addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
            });

            document.getElementById('densitySlider').addEventListener('input', (e) => {
                density = parseFloat(e.target.value);
            });
        }

        function updateBackgroundColor() {
            if (scene && renderer) {
                const newBgColor = bgColors[currentBgColor];
                scene.background.setHex(newBgColor);
                scene.fog.color.setHex(newBgColor);
            }
        }

        function updateModelColor() {
            if (glitchMaterial && model) {
                glitchMaterial.color.setHex(modelColors[currentModelColor]);
                glitchMaterial.needsUpdate = true;
            }
        }

        function updateTexture() {
            const ctx = glitchContext;
            const w = textureSize;
            const h = textureSize;

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, w, h);

            switch(currentTexture) {
                case 'mist':
                    drawMist(ctx, w, h);
                    break;
                case 'lasergrid':
                    drawLaserGrid(ctx, w, h);
                    break;
            }

            glitchTexture.needsUpdate = true;
        }

        function drawMist(ctx, w, h) {
            const colors = colorPalettes[currentColor];
            
            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b };
            }
            
            for (let layer = 0; layer < 5; layer++) {
                const layerOpacity = (0.8 - layer * 0.1) * intensity;
                const layerSpeed = speed * (0.1 + layer * 0.05);
                
                for (let i = 0; i < 15; i++) {
                    const x = (i * w / 15) + Math.sin(time * layerSpeed + i + layer) * 40;
                    const y = (layer * h / 5) + Math.cos(time * layerSpeed * 0.7 + i) * 30;
                    const radius = (20 + layer * 15) * density;
                    
                    const mistGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                    
                    const primaryRgb = hexToRgb(colors.primary);
                    const secondaryRgb = hexToRgb(colors.secondary);
                    const accentRgb = hexToRgb(colors.accent);
                    
                    const alpha = layerOpacity * 0.3;
                    
                    mistGradient.addColorStop(0, `rgba(${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}, ${alpha})`);
                    mistGradient.addColorStop(0.6, `rgba(${secondaryRgb.r}, ${secondaryRgb.g}, ${secondaryRgb.b}, ${alpha * 0.5})`);
                    mistGradient.addColorStop(1, `rgba(${accentRgb.r}, ${accentRgb.g}, ${accentRgb.b}, 0)`);
                    
                    ctx.fillStyle = mistGradient;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function drawLaserGrid(ctx, w, h) {
            const colors = colorPalettes[currentColor];
            const gridSize = 30 / density;
            
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.7 * intensity;
            
            for (let x = 0; x < w; x += gridSize) {
                const offset = Math.sin(time * speed * 0.5 + x * 0.01) * 8;
                const opacity = Math.sin(time * speed * 0.3 + x * 0.005) * 0.3 + 0.7;
                
                ctx.globalAlpha = opacity * intensity;
                ctx.beginPath();
                ctx.moveTo(x + offset, 0);
                ctx.lineTo(x + offset, h);
                ctx.stroke();
            }
            
            for (let y = 0; y < h; y += gridSize) {
                const offset = Math.cos(time * speed * 0.5 + y * 0.01) * 8;
                const opacity = Math.cos(time * speed * 0.3 + y * 0.005) * 0.3 + 0.7;
                
                ctx.globalAlpha = opacity * intensity;
                ctx.beginPath();
                ctx.moveTo(0, y + offset);
                ctx.lineTo(w, y + offset);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }

        function loadModel() {
            const loader = new GLTFLoader();
            const modelPath = "{% static 'private/face_mask.glb' %}";
            
            loader.load(
                modelPath,
                (gltf) => {
                    model = gltf.scene;
                    
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.material = glitchMaterial;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const modelScale = 4 / maxDim;
                    
                    model.scale.setScalar(modelScale);
                    model.position.sub(center.multiplyScalar(modelScale));
                    model.position.y = 0.6;
                    
                    scene.add(model);
                    
                    controls.target.copy(model.position);
                    controls.update();
                    
                    document.getElementById('loading').classList.add('hidden');
                },
                (progress) => {
                    console.log('Progreso:', (progress.loaded / progress.total * 100) + '%');
                },
                (error) => {
                    console.error('Error:', error);
                    document.getElementById('loading').textContent = 'ERROR: Verifica que el modelo existe en: ' + modelPath;
                }
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016 * speed;
            
            // Animaciones del modelo seg√∫n el estado con transiciones fluidas
            if (model) {
                // Calcular rotaciones objetivo seg√∫n el estado
                switch(animationState) {
                    case 'idle':
                        // Movimiento sutil de reposo
                        targetRotationX = Math.sin(time * 0.2) * 0.02;
                        targetRotationY = Math.sin(time * 0.3) * 0.1;
                        targetRotationZ = Math.sin(time * 0.25) * 0.05;
                        targetPositionZ = 0;
                        break;
                        
                    case 'processing':
                        // Animaci√≥n de "pensamiento" - inclinaci√≥n y pulso
                        targetRotationX = Math.sin(time * 0.7) * 0.08 - 0.05; // Inclinar hacia abajo
                        targetRotationY = Math.sin(time * 0.5) * 0.15;
                        targetRotationZ = Math.sin(time * 0.4) * 0.06;
                        targetPositionZ = 0;
                        
                        // Pulso en la intensidad de la textura
                        const processingPulse = Math.sin(time * 3) * 0.3 + 0.7;
                        intensity = Math.max(0.1, Math.min(2.5, processingPulse * 1.2));
                        break;
                        
                    case 'speaking':
                        // Animaci√≥n de habla - movimientos m√°s din√°micos y humanos
                        const speakBase = time * 2;
                        const speakVariation = Math.sin(time * 1.3) * 0.5 + 0.5;
                        
                        // Asentimiento ocasional
                        targetRotationX = Math.sin(speakBase * 0.8) * 0.1 * speakVariation;
                        
                        // Giro ligero de cabeza con doble frecuencia para naturalidad
                        targetRotationY = Math.sin(speakBase * 0.6 + 1) * 0.12 + 
                                         Math.sin(speakBase * 1.7) * 0.05;
                        
                        // Inclinaci√≥n din√°mica
                        targetRotationZ = Math.sin(speakBase * 0.9 + 2) * 0.08 * speakVariation;
                        
                        // Posici√≥n Z fija para evitar que se vea m√°s grande
                        targetPositionZ = 0;
                        break;
                }
                
                // Aplicar interpolaci√≥n suave (lerp) para transiciones fluidas
                currentRotationX += (targetRotationX - currentRotationX) * transitionSpeed;
                currentRotationY += (targetRotationY - currentRotationY) * transitionSpeed;
                currentRotationZ += (targetRotationZ - currentRotationZ) * transitionSpeed;
                currentPositionZ += (targetPositionZ - currentPositionZ) * transitionSpeed;
                
                // Aplicar las rotaciones interpoladas al modelo
                model.rotation.x = currentRotationX;
                model.rotation.y = currentRotationY;
                model.rotation.z = currentRotationZ;
                model.position.z = currentPositionZ;
            }
            
            // Actualizar textura cada 3 frames para mejor rendimiento
            if (Math.floor(time * 60) % 3 === 0) {
                updateTexture();
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>

    <!-- L√≥gica de Comunicaci√≥n -->
    <script src="{% static 'js/secret/agent_AJAX_logic.js' %}"></script>
</body>
</html>